{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Jean-Nvim \u00b6 Overview \u00b6 Jean-Nvim is a lua library providing tools to ease the development of nvim plugins in Lua.","title":"Home"},{"location":"#jean-nvim","text":"","title":"Jean-Nvim"},{"location":"#overview","text":"Jean-Nvim is a lua library providing tools to ease the development of nvim plugins in Lua.","title":"Overview"},{"location":"api/api/","text":"unknown \u00b6","title":"Api Reference"},{"location":"api/api/#unknown","text":"","title":"unknown"},{"location":"api/autocommand/","text":"unknown \u00b6 Classes \u00b6 Autocommand \u00b6 Constructor \u00b6 Signature Autocommand ( event : any , options : any ) Parameter Type Description Default event * any options * any Methods \u00b6 delete() \u00b6 Signature function Autocommand : delete () -> nil","title":"unknown"},{"location":"api/autocommand/#unknown","text":"","title":"unknown"},{"location":"api/autocommand/#classes","text":"","title":"Classes"},{"location":"api/autocommand/#autocommand","text":"","title":"Autocommand"},{"location":"api/autocommand/#constructor","text":"Signature Autocommand ( event : any , options : any ) Parameter Type Description Default event * any options * any","title":"Constructor"},{"location":"api/autocommand/#methods","text":"","title":"Methods"},{"location":"api/autocommand/#delete","text":"Signature function Autocommand : delete () -> nil","title":"delete()"},{"location":"api/buffer/","text":"Buffer \u00b6 Object oriented wrapper around Neovim buffer. This class provides only an OO convenience wrapper around the various lua function that handle neovim buffers. No feature here, just another way to call the nvim lua api. Constructor \u00b6 Signature Buffer ( options : table [ any ]) Parameter Type Description Default options table[any] Buffer options. {} Notes Options should be a table of options to set on this buffer. It can be any buffer options or Buffer property. (For example, you can set a name key, and the buffer name will be set through the Buffer.name property). Usage local buffer = Buffer ({ name = \"otter list\" , listed = false , modifiable = false }) Properties \u00b6 Name Type Access Description lines number read-only name string read/write Name of the buffer. Wraps nvim_buf_get_name and nvim_buf_set_name . ___ any read/write Get or set an option for this buffer. Wraps vim.bo . See the nvim documentation for a list of available options. Methods \u00b6 from_handle() \u00b6 Wraps a neovim buffer. Signature function Buffer . from_handle ( handle : number ) -> nil Parameter Type Description Default handle * number Numerical buffer id. Notes Create an instance of Buffer that wraps the existing buffer with the given handle (buf). Usage local buffer = Buffer . wrap ( vim . api . nvim_get_current_buf ()) list() \u00b6 Return an iterator existing nvim buffers. Signature function Buffer . list () -> jlua . iterator Returns Description jlua.iterator An iterator of buffer. Notes Wraps nvim_list_bufs . Usage for buffer in Buffer . list () do buffer : delete () end edit() \u00b6 Signature function Buffer : edit () -> nil Notes Context manager getting a Range over the whole buffer as context argument. If the buffer has the option modifiable = false, it will be automatically set to true in the context, and reset to false when the context is exited. See Range for the why of a context manager here. get_lines() \u00b6 Get the text lines of the buffer. Signature function Buffer : get_lines ( start : number , end_ : number ) -> jlua . list Parameter Type Description Default start number The starting line. 0 end_ number The ending line. -1 Returns Description jlua.list A list of string. Notes See nvim_buf_get_lines . By default, return all the lines of the buffer. Usage buffer : get_lines ( 2 , - 2 ) -- Get the lines from the second to the second before the end. set_lines() \u00b6 Replaces text in a buffer. Signature function Buffer : set_lines ( lines : [ string ], start : number , end_ : number ) -> jlua . iterator Parameter Type Description Default lines * [string] The text line to append to the buffer. start number The starting line. -1 end_ number The ending line. -1 Returns Description jlua.iterator An iterator of buffer. Notes Wraps nvim_buf_set_lines . If start and end_ are not provided, the lines are appended to the buffer. Usage buffer : set_lines ({ \"jean-jean\" , \"jean-jean jacques\" }) delete() \u00b6 Delete a buffer. Signature function Buffer : delete ( options : [ table ]) -> nil Parameter Type Description Default options [table] Delete options {} Notes Wraps nvim_buf_delete . See this link for more informations about the options. Usage buffer : delete ({ force = true })","title":"Buffer"},{"location":"api/buffer/#buffer","text":"Object oriented wrapper around Neovim buffer. This class provides only an OO convenience wrapper around the various lua function that handle neovim buffers. No feature here, just another way to call the nvim lua api.","title":"Buffer"},{"location":"api/buffer/#constructor","text":"Signature Buffer ( options : table [ any ]) Parameter Type Description Default options table[any] Buffer options. {} Notes Options should be a table of options to set on this buffer. It can be any buffer options or Buffer property. (For example, you can set a name key, and the buffer name will be set through the Buffer.name property). Usage local buffer = Buffer ({ name = \"otter list\" , listed = false , modifiable = false })","title":"Constructor"},{"location":"api/buffer/#properties","text":"Name Type Access Description lines number read-only name string read/write Name of the buffer. Wraps nvim_buf_get_name and nvim_buf_set_name . ___ any read/write Get or set an option for this buffer. Wraps vim.bo . See the nvim documentation for a list of available options.","title":"Properties"},{"location":"api/buffer/#methods","text":"","title":"Methods"},{"location":"api/buffer/#from_handle","text":"Wraps a neovim buffer. Signature function Buffer . from_handle ( handle : number ) -> nil Parameter Type Description Default handle * number Numerical buffer id. Notes Create an instance of Buffer that wraps the existing buffer with the given handle (buf). Usage local buffer = Buffer . wrap ( vim . api . nvim_get_current_buf ())","title":"from_handle()"},{"location":"api/buffer/#list","text":"Return an iterator existing nvim buffers. Signature function Buffer . list () -> jlua . iterator Returns Description jlua.iterator An iterator of buffer. Notes Wraps nvim_list_bufs . Usage for buffer in Buffer . list () do buffer : delete () end","title":"list()"},{"location":"api/buffer/#edit","text":"Signature function Buffer : edit () -> nil Notes Context manager getting a Range over the whole buffer as context argument. If the buffer has the option modifiable = false, it will be automatically set to true in the context, and reset to false when the context is exited. See Range for the why of a context manager here.","title":"edit()"},{"location":"api/buffer/#get_lines","text":"Get the text lines of the buffer. Signature function Buffer : get_lines ( start : number , end_ : number ) -> jlua . list Parameter Type Description Default start number The starting line. 0 end_ number The ending line. -1 Returns Description jlua.list A list of string. Notes See nvim_buf_get_lines . By default, return all the lines of the buffer. Usage buffer : get_lines ( 2 , - 2 ) -- Get the lines from the second to the second before the end.","title":"get_lines()"},{"location":"api/buffer/#set_lines","text":"Replaces text in a buffer. Signature function Buffer : set_lines ( lines : [ string ], start : number , end_ : number ) -> jlua . iterator Parameter Type Description Default lines * [string] The text line to append to the buffer. start number The starting line. -1 end_ number The ending line. -1 Returns Description jlua.iterator An iterator of buffer. Notes Wraps nvim_buf_set_lines . If start and end_ are not provided, the lines are appended to the buffer. Usage buffer : set_lines ({ \"jean-jean\" , \"jean-jean jacques\" })","title":"set_lines()"},{"location":"api/buffer/#delete","text":"Delete a buffer. Signature function Buffer : delete ( options : [ table ]) -> nil Parameter Type Description Default options [table] Delete options {} Notes Wraps nvim_buf_delete . See this link for more informations about the options. Usage buffer : delete ({ force = true })","title":"delete()"},{"location":"api/context-handler/","text":"unknown \u00b6 Classes \u00b6 ContextHandler \u00b6 Constructor \u00b6 Signature ContextHandler ( namespace : any ) Parameter Type Description Default namespace * any Methods \u00b6 enable() \u00b6 Enable this context Signature function ContextHandler : enable () -> nil disable() \u00b6 Disable this context Signature function ContextHandler : disable () -> nil bind_function() \u00b6 Register a methood on self as a callback for a vim function Signature function ContextHandler : bind_function ( name : any ) -> nil Parameter Type Description Default name * any bind_autocommand() \u00b6 Register an autocommand for a method on self Signature function ContextHandler : bind_autocommand ( event : any , name : any , options : any ) -> nil Parameter Type Description Default event * any name * any options * any bind_user_autocommand() \u00b6 Register a user autocommand for a method on self Signature function ContextHandler : bind_user_autocommand ( name : any , options : any ) -> nil Parameter Type Description Default name * any options * any execute_user_autocommand() \u00b6 Execute an user autocommand Signature function ContextHandler : execute_user_autocommand ( name : any ) -> nil Parameter Type Description Default name * any bind_user_command() \u00b6 Register a user command for a method on self Signature function ContextHandler : bind_user_command ( name : any , options : any , buffer : any ) -> nil Parameter Type Description Default name * any options * any buffer * any get_function_identifier() \u00b6 Signature function ContextHandler : get_function_identifier ( name : any ) -> nil Parameter Type Description Default name * any get_command_identifier() \u00b6 Signature function ContextHandler : get_command_identifier ( name : any ) -> nil Parameter Type Description Default name * any","title":"unknown"},{"location":"api/context-handler/#unknown","text":"","title":"unknown"},{"location":"api/context-handler/#classes","text":"","title":"Classes"},{"location":"api/context-handler/#contexthandler","text":"","title":"ContextHandler"},{"location":"api/context-handler/#constructor","text":"Signature ContextHandler ( namespace : any ) Parameter Type Description Default namespace * any","title":"Constructor"},{"location":"api/context-handler/#methods","text":"","title":"Methods"},{"location":"api/context-handler/#enable","text":"Enable this context Signature function ContextHandler : enable () -> nil","title":"enable()"},{"location":"api/context-handler/#disable","text":"Disable this context Signature function ContextHandler : disable () -> nil","title":"disable()"},{"location":"api/context-handler/#bind_function","text":"Register a methood on self as a callback for a vim function Signature function ContextHandler : bind_function ( name : any ) -> nil Parameter Type Description Default name * any","title":"bind_function()"},{"location":"api/context-handler/#bind_autocommand","text":"Register an autocommand for a method on self Signature function ContextHandler : bind_autocommand ( event : any , name : any , options : any ) -> nil Parameter Type Description Default event * any name * any options * any","title":"bind_autocommand()"},{"location":"api/context-handler/#bind_user_autocommand","text":"Register a user autocommand for a method on self Signature function ContextHandler : bind_user_autocommand ( name : any , options : any ) -> nil Parameter Type Description Default name * any options * any","title":"bind_user_autocommand()"},{"location":"api/context-handler/#execute_user_autocommand","text":"Execute an user autocommand Signature function ContextHandler : execute_user_autocommand ( name : any ) -> nil Parameter Type Description Default name * any","title":"execute_user_autocommand()"},{"location":"api/context-handler/#bind_user_command","text":"Register a user command for a method on self Signature function ContextHandler : bind_user_command ( name : any , options : any , buffer : any ) -> nil Parameter Type Description Default name * any options * any buffer * any","title":"bind_user_command()"},{"location":"api/context-handler/#get_function_identifier","text":"Signature function ContextHandler : get_function_identifier ( name : any ) -> nil Parameter Type Description Default name * any","title":"get_function_identifier()"},{"location":"api/context-handler/#get_command_identifier","text":"Signature function ContextHandler : get_command_identifier ( name : any ) -> nil Parameter Type Description Default name * any","title":"get_command_identifier()"},{"location":"api/context/","text":"unknown \u00b6 Classes \u00b6 Context \u00b6 Constructor \u00b6 Signature Context () Methods \u00b6 add_function() \u00b6 Register a function in the context. Signature function Context : add_function ( name : any , callback : any ) -> nil Parameter Type Description Default name * any callback * any add_autocommand() \u00b6 Register an autocommand in the context. Signature function Context : add_autocommand ( events : any , options : any ) -> nil Parameter Type Description Default events * any options * any add_user_command() \u00b6 Register an user command in the context. Signature function Context : add_user_command ( name : any , callback : any , options : any , buffer : any ) -> nil Parameter Type Description Default name * any callback * any options * any buffer * any map() \u00b6 Register a key mapping into the context Signature function Context : map ( mode : any , lhs : any , rhs : any , options : any ) -> nil Parameter Type Description Default mode * any lhs * any rhs * any options * any enable() \u00b6 Enable the context Signature function Context : enable () -> nil disable() \u00b6 Disable the context Signature function Context : disable () -> nil","title":"unknown"},{"location":"api/context/#unknown","text":"","title":"unknown"},{"location":"api/context/#classes","text":"","title":"Classes"},{"location":"api/context/#context","text":"","title":"Context"},{"location":"api/context/#constructor","text":"Signature Context ()","title":"Constructor"},{"location":"api/context/#methods","text":"","title":"Methods"},{"location":"api/context/#add_function","text":"Register a function in the context. Signature function Context : add_function ( name : any , callback : any ) -> nil Parameter Type Description Default name * any callback * any","title":"add_function()"},{"location":"api/context/#add_autocommand","text":"Register an autocommand in the context. Signature function Context : add_autocommand ( events : any , options : any ) -> nil Parameter Type Description Default events * any options * any","title":"add_autocommand()"},{"location":"api/context/#add_user_command","text":"Register an user command in the context. Signature function Context : add_user_command ( name : any , callback : any , options : any , buffer : any ) -> nil Parameter Type Description Default name * any callback * any options * any buffer * any","title":"add_user_command()"},{"location":"api/context/#map","text":"Register a key mapping into the context Signature function Context : map ( mode : any , lhs : any , rhs : any , options : any ) -> nil Parameter Type Description Default mode * any lhs * any rhs * any options * any","title":"map()"},{"location":"api/context/#enable","text":"Enable the context Signature function Context : enable () -> nil","title":"enable()"},{"location":"api/context/#disable","text":"Disable the context Signature function Context : disable () -> nil","title":"disable()"},{"location":"api/extmark/","text":"Extmark \u00b6 Object-oriented extmarks Extmark object wrapper can be constructed from Range objects. Constructor \u00b6 Properties \u00b6 Name Type Access Description position {row:number,col:number} read/write Get / set the position of this mark, as a table with a row and a col keys. ___ any read-only Get or set an option on this mark. Any property get can be one of the keys that can be passed as option to nvim_buf_set_extmark , the corresponding option will be get / set on this mark. Methods \u00b6 _newindex() \u00b6 Signature function Extmark : _newindex ( key : any , value : any ) -> nil Parameter Type Description Default key * any value * any","title":"Extmark"},{"location":"api/extmark/#extmark","text":"Object-oriented extmarks Extmark object wrapper can be constructed from Range objects.","title":"Extmark"},{"location":"api/extmark/#constructor","text":"","title":"Constructor"},{"location":"api/extmark/#properties","text":"Name Type Access Description position {row:number,col:number} read/write Get / set the position of this mark, as a table with a row and a col keys. ___ any read-only Get or set an option on this mark. Any property get can be one of the keys that can be passed as option to nvim_buf_set_extmark , the corresponding option will be get / set on this mark.","title":"Properties"},{"location":"api/extmark/#methods","text":"","title":"Methods"},{"location":"api/extmark/#_newindex","text":"Signature function Extmark : _newindex ( key : any , value : any ) -> nil Parameter Type Description Default key * any value * any","title":"_newindex()"},{"location":"api/logging/","text":"unknown \u00b6 Classes \u00b6 LogBuffer \u00b6 Constructor \u00b6 Signature LogBuffer ( logger_name : any ) Parameter Type Description Default logger_name * any Methods \u00b6 _handle() \u00b6 Signature function LogBuffer : _handle ( record : any ) -> nil Parameter Type Description Default record * any _set_level() \u00b6 Signature function LogBuffer : _set_level ( args : any ) -> nil Parameter Type Description Default args * any _on_delete() \u00b6 Signature function LogBuffer : _on_delete () -> nil","title":"unknown"},{"location":"api/logging/#unknown","text":"","title":"unknown"},{"location":"api/logging/#classes","text":"","title":"Classes"},{"location":"api/logging/#logbuffer","text":"","title":"LogBuffer"},{"location":"api/logging/#constructor","text":"Signature LogBuffer ( logger_name : any ) Parameter Type Description Default logger_name * any","title":"Constructor"},{"location":"api/logging/#methods","text":"","title":"Methods"},{"location":"api/logging/#_handle","text":"Signature function LogBuffer : _handle ( record : any ) -> nil Parameter Type Description Default record * any","title":"_handle()"},{"location":"api/logging/#_set_level","text":"Signature function LogBuffer : _set_level ( args : any ) -> nil Parameter Type Description Default args * any","title":"_set_level()"},{"location":"api/logging/#_on_delete","text":"Signature function LogBuffer : _on_delete () -> nil","title":"_on_delete()"},{"location":"api/namespace/","text":"Namespace \u00b6 Object oriented wrapper around Neovim namespace. Namespaces are used to scope buffer highlighting and marks. Constructor \u00b6 Signature Namespace ( name : string ) Parameter Type Description Default name string Namespace name, or nil for an anonymous nil Notes Create a new namespace, or wraps an existing namespace. Wraps nvim_create_namespace . If no name argument is given, create an anonymous namespace. If a namespace with the given name already exists this instance will wrap this same namespace. Properties \u00b6 Name Type Access Description id number read-only Get the numerical id of this namespace.","title":"Namespace"},{"location":"api/namespace/#namespace","text":"Object oriented wrapper around Neovim namespace. Namespaces are used to scope buffer highlighting and marks.","title":"Namespace"},{"location":"api/namespace/#constructor","text":"Signature Namespace ( name : string ) Parameter Type Description Default name string Namespace name, or nil for an anonymous nil Notes Create a new namespace, or wraps an existing namespace. Wraps nvim_create_namespace . If no name argument is given, create an anonymous namespace. If a namespace with the given name already exists this instance will wrap this same namespace.","title":"Constructor"},{"location":"api/namespace/#properties","text":"Name Type Access Description id number read-only Get the numerical id of this namespace.","title":"Properties"},{"location":"api/path/","text":"unknown \u00b6 Classes \u00b6 Path \u00b6 Methods \u00b6 dir() \u00b6 Return an iterator over the children of this path. Signature function Path : dir () -> nil is_dir() \u00b6 Check if a path points to a directory Signature function Path : is_dir () -> nil is_file() \u00b6 Check if a path points to a file Signature function Path : is_file () -> nil to_absolute() \u00b6 Convert a relative path to an absolute. Signature function Path : to_absolute () -> nil","title":"unknown"},{"location":"api/path/#unknown","text":"","title":"unknown"},{"location":"api/path/#classes","text":"","title":"Classes"},{"location":"api/path/#path","text":"","title":"Path"},{"location":"api/path/#methods","text":"","title":"Methods"},{"location":"api/path/#dir","text":"Return an iterator over the children of this path. Signature function Path : dir () -> nil","title":"dir()"},{"location":"api/path/#is_dir","text":"Check if a path points to a directory Signature function Path : is_dir () -> nil","title":"is_dir()"},{"location":"api/path/#is_file","text":"Check if a path points to a file Signature function Path : is_file () -> nil","title":"is_file()"},{"location":"api/path/#to_absolute","text":"Convert a relative path to an absolute. Signature function Path : to_absolute () -> nil","title":"to_absolute()"},{"location":"api/range/","text":"Range \u00b6 Range is the entry point to modify buffer content, higlights, virtual-text... To create a new range, use edit method of Buffer : local with = require ( \"jlua.context\" ). with local buffer = Buffer () with ( buffer : edit (), function ( buffer_range ) buffer_range . text * { \"hello\" , \"world\" } end ) Range uses extmarks to mark the start and end of the pointed area. This means that if you insert or delete text inside a range by any means, the range boundaries will be updated accordingly. This explains the use of a context manager : the marks at the range boundaries are cleared when the edit context is exited. Constructor \u00b6 Properties \u00b6 Name Type Access Description start {row:number,col:number} read-only Get the start position of this range, as a table with a row and a col keys. end_ {row:number,col:number} read-only Get the end position of this range, as a table with a row and a col keys. text {string} read/write Get the lines of text in this range Methods \u00b6 clear_namespace() \u00b6 Clears a namespace in the pointed buffer's range area. Signature function Range : clear_namespace ( namespace : Namespace ) -> nil Parameter Type Description Default namespace * Namespace Namespace to clear. insert() \u00b6 Insert lines at the given position, relative to the range boundaries. Signature function Range : insert ({ string }: content , row : number , col : number ) -> Range Parameter Type Description Default {string} * content Table of lines to insert. row number Insert row, relative to this range. -1 col number Insert col, relative to this range. -1 Returns Description Range Range covering the inserted content. Notes row and col are 0-indexed. If row is negative, it will be interpreted as relative to the range end boundary. If no row or col is provided, the content will be inserted at the end of this range. set_extmark() \u00b6 Add an extmark, at a position in this range. Signature function Range : set_extmark ( namespace : Namespace , row : number , col : number , options : table ) -> Extmark Parameter Type Description Default namespace * Namespace Namespace of the mark. row number Row of the mark, relative to this range. 0 col number Col of the mark, relative to this range. 0 options table Additional options to pass to vim.api.nvim_buf_set_extmark. {} Returns Description Extmark Wrapper around the created extmark Notes If options.end_row or options.end_col are set, the position will be intepreted as relative to this range's bounds. _get_absolute_position() \u00b6 Signature function Range : _get_absolute_position ( row : any , col : any ) -> nil Parameter Type Description Default row * any col * any","title":"Range"},{"location":"api/range/#range","text":"Range is the entry point to modify buffer content, higlights, virtual-text... To create a new range, use edit method of Buffer : local with = require ( \"jlua.context\" ). with local buffer = Buffer () with ( buffer : edit (), function ( buffer_range ) buffer_range . text * { \"hello\" , \"world\" } end ) Range uses extmarks to mark the start and end of the pointed area. This means that if you insert or delete text inside a range by any means, the range boundaries will be updated accordingly. This explains the use of a context manager : the marks at the range boundaries are cleared when the edit context is exited.","title":"Range"},{"location":"api/range/#constructor","text":"","title":"Constructor"},{"location":"api/range/#properties","text":"Name Type Access Description start {row:number,col:number} read-only Get the start position of this range, as a table with a row and a col keys. end_ {row:number,col:number} read-only Get the end position of this range, as a table with a row and a col keys. text {string} read/write Get the lines of text in this range","title":"Properties"},{"location":"api/range/#methods","text":"","title":"Methods"},{"location":"api/range/#clear_namespace","text":"Clears a namespace in the pointed buffer's range area. Signature function Range : clear_namespace ( namespace : Namespace ) -> nil Parameter Type Description Default namespace * Namespace Namespace to clear.","title":"clear_namespace()"},{"location":"api/range/#insert","text":"Insert lines at the given position, relative to the range boundaries. Signature function Range : insert ({ string }: content , row : number , col : number ) -> Range Parameter Type Description Default {string} * content Table of lines to insert. row number Insert row, relative to this range. -1 col number Insert col, relative to this range. -1 Returns Description Range Range covering the inserted content. Notes row and col are 0-indexed. If row is negative, it will be interpreted as relative to the range end boundary. If no row or col is provided, the content will be inserted at the end of this range.","title":"insert()"},{"location":"api/range/#set_extmark","text":"Add an extmark, at a position in this range. Signature function Range : set_extmark ( namespace : Namespace , row : number , col : number , options : table ) -> Extmark Parameter Type Description Default namespace * Namespace Namespace of the mark. row number Row of the mark, relative to this range. 0 col number Col of the mark, relative to this range. 0 options table Additional options to pass to vim.api.nvim_buf_set_extmark. {} Returns Description Extmark Wrapper around the created extmark Notes If options.end_row or options.end_col are set, the position will be intepreted as relative to this range's bounds.","title":"set_extmark()"},{"location":"api/range/#_get_absolute_position","text":"Signature function Range : _get_absolute_position ( row : any , col : any ) -> nil Parameter Type Description Default row * any col * any","title":"_get_absolute_position()"},{"location":"api/test-suite/","text":"unknown \u00b6","title":"unknown"},{"location":"api/test-suite/#unknown","text":"","title":"unknown"},{"location":"api/user-command/","text":"unknown \u00b6 Classes \u00b6 UserCommand \u00b6 Constructor \u00b6 Signature UserCommand ( name : any , command : any , options : any , buffer : any ) Parameter Type Description Default name * any command * any options * any buffer * any Methods \u00b6 delete() \u00b6 Delete the user command Signature function UserCommand : delete () -> nil","title":"unknown"},{"location":"api/user-command/#unknown","text":"","title":"unknown"},{"location":"api/user-command/#classes","text":"","title":"Classes"},{"location":"api/user-command/#usercommand","text":"","title":"UserCommand"},{"location":"api/user-command/#constructor","text":"Signature UserCommand ( name : any , command : any , options : any , buffer : any ) Parameter Type Description Default name * any command * any options * any buffer * any","title":"Constructor"},{"location":"api/user-command/#methods","text":"","title":"Methods"},{"location":"api/user-command/#delete","text":"Delete the user command Signature function UserCommand : delete () -> nil","title":"delete()"},{"location":"usage/_index/","text":"","title":"Usage"},{"location":"usage/context/","text":"Context \u00b6","title":"Context"},{"location":"usage/context/#context","text":"","title":"Context"}]}